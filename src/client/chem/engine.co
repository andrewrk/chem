#depend "chem/vec2d"
#depend "chem/event_emitter"
#depend "private/button_offset"

const {Vec2d, EventEmitter, Button} = window@Chem
const {MOUSE_OFFSET, KEY_OFFSET} = window@Chem@Private
const _exports = window@Chem
const _private = window@Chem@Private

_exports.Engine = class Engine extends EventEmitter
  const target_fps = 60
  const target_spf = 1 / target_fps
  const fps_smoothness = 0.9
  const fps_one_frame_weight = 1.0 - fps_smoothness

  const requestAnimationFrame = window.requestAnimationFrame or \
    window.webkitRequestAnimationFrame or \
    window.mozRequestAnimationFrame or \
    window.oRequestAnimationFrame or \
    window.msRequestAnimationFrame or \
    !(cb) -> window.setTimeout(cb, target_spf * 1000)

  (@canvas) ~>
    super()
    @listeners = []

    # add tabindex property to canvas so that it can receive keyboard input
    @canvas.tabIndex = 0

    @context = @canvas.getContext("2d")
    @size = Vec2d(@canvas.width, @canvas.height)
    @fps = target_fps

    @setMinFps(20)

  setSize: !(@size) ->
    @canvas.width = @size.x
    @canvas.height = @size.y

  setMinFps: !->
    @max_spf = 1 / it

  start: !->
    @attachListeners()
    @startMainLoop()

  stop: !->
    @stopMainLoop()
    @removeListeners()

  buttonState: (button) -> !!@button_states[button]
  buttonJustPressed: (button) -> !!@btn_just_pressed[button]

  draw: !(batch) ->
    const now = new Date()

    for sprites of batch.sprites
      for id, sprite in sprites
        const frame = sprite.animation.frames[sprite.getFrameIndex()]
        @context.save()
        @context.translate sprite.pos.x, sprite.pos.y
        @context.scale sprite.scale.x, sprite.scale.y
        @context.rotate sprite.rotation
        @context.drawImage _private.spritesheet, frame.pos.x, frame.pos.y, \
          frame.size.x, frame.size.y, \
          -sprite.animation.anchor.x, -sprite.animation.anchor.y, \
          frame.size.x, frame.size.y
        @context.restore()

  drawFps: !->
    @context.fillText "#{Math.round(@fps)} fps", 0, @size.y

  # private
  startMainLoop: !->
    previous_update = new Date()
    @main_loop_on = true

    const mainLoop = !~>
      const now = new Date()
      const delta = (now - previous_update) / 1000
      previous_update := now
      # make sure dt is never zero
      # if FPS is too low, lag instead of causing physics glitches
      const dt = 0.00000001 >? delta <? @max_spf
      const multiplier = dt / target_spf
      @emit \update, dt, multiplier
      @btn_just_pressed = {}

      @emit \draw, @context
      const fps = 1 / delta <? 90000
      @fps = @fps * fps_smoothness + fps * fps_one_frame_weight

      if @main_loop_on
        requestAnimationFrame(mainLoop, @canvas)
    requestAnimationFrame(mainLoop, @canvas)

  attachListeners: !->
    @button_states = {}
    @btn_just_pressed = {}

    const addListener = !(element, event_name, listener) ~>
      @listeners.push do
        [element, event_name, listener]
      element.addEventListener(event_name, listener, false)

    # disable right click context menu
    addListener @canvas, \contextmenu, !(event) ~>
      event.preventDefault()

    # mouse input
    @mouse_pos = Vec2d()
    const forwardMouseEvent = !(name, event) ~>

    addListener @canvas, \mousemove, !(event) ~>
      @mouse_pos = Vec2d(event.offsetX, event.offsetY)
      @emit \mousemove, @mouse_pos, MOUSE_OFFSET + event.which

    addListener @canvas, \mousedown, !(event) ~>
      const button_id = MOUSE_OFFSET + event.which
      @button_states[button_id] = true
      @btn_just_pressed[button_id] = true
      @emit \buttondown, button_id

    addListener @canvas, \mouseup, !(event) ~>
      const button_id = MOUSE_OFFSET + event.which
      @button_states[button_id] = false
      @emit \buttonup, button_id

    # keyboard input
    addListener @canvas, \keydown, (event) ~>
      const button_id = KEY_OFFSET + event.which
      @button_states[button_id] = true
      @btn_just_pressed[button_id] = true
      @emit \buttondown, button_id
      event.preventDefault()
      false

    addListener @canvas, \keyup, (event) ~>
      const button_id = KEY_OFFSET + event.which
      @button_states[button_id] = false
      @emit \buttonup, button_id
      event.preventDefault()
      false

  removeListeners: !->
    for [element, event_name, listener] of @listeners
      element.removeEventListener(event_name, listener, false)
    @listeners = []

  stopMainLoop: !->
    @main_loop_on = false

